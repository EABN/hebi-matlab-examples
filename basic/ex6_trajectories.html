
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ex6_trajectories</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-07-15"><meta name="DC.source" content="ex6_trajectories.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">General</a></li><li><a href="#3">Single Actuator Joint Trajectory</a></li><li><a href="#5">Moving a robot to random waypoints</a></li></ul></div><pre class="codeinput"><span class="comment">% This example shows howto use the HebiTrajectoryGenerator API to create</span>
<span class="comment">% paths to smoothly move through waypoints.</span>
<span class="comment">%</span>
<span class="comment">% Requirements:  MATLAB 2013b or higher</span>
<span class="comment">%</span>
<span class="comment">% Author:        Florian Enner</span>
<span class="comment">% Created:       14 July, 2017</span>
<span class="comment">% API:           hebi-matlab-1.0</span>
<span class="comment">%</span>
<span class="comment">% Copyright 2017 HEBI Robotics</span>
</pre><h2 id="2">General</h2><p>For series elastic actuators such as the X-series modules it is important to command smooth trajectories to avoid oscillations induced by the spring element. Additionally, it helps significantly to not only command positions, but also velocities and if possible torques.</p><p>Trajectories work on a joint level and are technically independent of the kinematic configuration. The API however requires knowledge of HebiKinematics to access meta-data such as velocity limits. Thus, position and velocity control can be done with only knowledge of the number of joints in a system. A full model of the system is however required for</p><div><ul><li>Torque control, i.e., converting joint accelerations to corresponding   torques and forces</li><li>'Linear'-type trajectories that move the end-effector in world   coordinates</li></ul></div><h2 id="3">Single Actuator Joint Trajectory</h2><p>The following exampe creates a trajectory through position waypoints for a single actuator. The time vector can be automatically determined based on the joint limits. Alternatively the time can be set manually.</p><div><ul><li>'Duration' sets the total desired duration</li><li>'Time' sets the times at which each waypoint should be hit</li></ul></div><p>For more options please see our online documentation or the corresponding help files.</p><pre class="codeinput"><span class="comment">% Setup single module for accessing meta-data</span>
kin = HebiKinematics();
kin.addBody(<span class="string">'X5-1'</span>);
trajGen = HebiTrajectoryGenerator(kin);
trajGen.setSpeedFactor(0.5); <span class="comment">% slow down to half speed (good for testing)</span>

<span class="comment">% Calculate trajectory through position waypoints</span>
waypoints = [0 2 -1 -2 1 0];
trajectory = trajGen.newJointMove(waypoints);
</pre><pre class="codeinput"><span class="comment">% Evaluate trajectory at 100 Hz resolution</span>
t = 0:0.01:trajectory.getDuration();
[p,v,a] = trajectory.getState(t); <span class="comment">% scalar or vector</span>
display(waypoints);

<span class="comment">% Display result</span>
plot(t,p); hold <span class="string">on</span>; grid <span class="string">on</span>;
plot(t,v);
plot(t,a);
tWpt = trajectory.getWaypointTime();
plot(tWpt, trajectory.getState(tWpt), <span class="string">'bo'</span>); hold <span class="string">off</span>;
legend <span class="string">position</span> <span class="string">velocity</span> <span class="string">acceleration</span> <span class="string">waypoint</span>
xlabel(<span class="string">'time [s]'</span>);
ylabel(<span class="string">'value [rad, rad/s, rad/s^2]'</span>);
</pre><pre class="codeoutput">
waypoints =

     0     2    -1    -2     1     0

</pre><img vspace="5" hspace="5" src="ex6_trajectories_01.png" alt=""> <h2 id="5">Moving a robot to random waypoints</h2><p>In addition to providing low-level access to the raw trajectory, we provide convenience wrappers that simplify interactions with the HebiGroup and HebiKinematics APIs.</p><p>'moveJoint()' moves between waypoints and blocks until the trajectory is executed.</p><p><img vspace="5" hspace="5" src="resources/2dof_RR_ik_xy.png" alt=""> </p><pre class="codeinput"><span class="comment">% Setup 2 dof planar RR arm</span>
kin = HebiKinematics();
kin.addBody(<span class="string">'X5-4'</span>); <span class="comment">% base joint</span>
kin.addBody(<span class="string">'X5-Link'</span>, <span class="string">'ext'</span>, 0.35, <span class="string">'twist'</span>, pi);
kin.addBody(<span class="string">'X5-1'</span>);
kin.addBody(<span class="string">'X5-Link'</span>, <span class="string">'ext'</span>, 0.25, <span class="string">'twist'</span>, pi);

<span class="comment">% Setup trajectory generator</span>
trajGen = HebiTrajectoryGenerator(kin);
trajGen.setSpeedFactor(0.5);
trajGen.setMinDuration(0.5);

<span class="comment">% Connect to modules (replace names with your own)</span>
group = HebiLookup.newGroupFromNames(<span class="string">'2dof'</span>, {<span class="string">'base'</span>, <span class="string">'knee'</span>});

<span class="comment">% Determine direction of gravity to compensate for gravitational effects</span>
fbk = group.getNextFeedback(); <span class="comment">% assume fixed base</span>
gravityVec = -[fbk.accelX(1) fbk.accelY(1) fbk.accelZ(1)];

<span class="comment">% Move to random waypoints</span>
current = fbk.position;
<span class="keyword">for</span> i = 1:20

    next = (rand(size(current)) - 0.5) * pi/2; <span class="comment">% max +/- pi/2</span>
    trajGen.moveJoint(group,      <span class="keyword">...</span><span class="comment"> % target actuators</span>
        [current; next],          <span class="keyword">...</span><span class="comment"> % waypoints</span>
        <span class="string">'GravityVec'</span>, gravityVec, <span class="keyword">...</span><span class="comment"> % compensate for gravity</span>
        <span class="string">'EnableDynamicsComp'</span>, true);  <span class="comment">% compensate for accelerations</span>
    current = next;

<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="comment">% Display</span>
display(kin);
display(trajGen);
display(group);
</pre><pre class="codeoutput">
kin = 

 &lt;a href="matlab:helpPopup HebiKinematics"&gt;HebiKinematics&lt;/a&gt; with properties:

    numBodies: 4
       numDoF: 2
         mass: 1.35 [kg]
      payload: 0 [kg]

    body  type        isDoF  mass 
    ----  ----------  -----  -----
    1     X5-4        true   0.335
    2     X5-Link     false  0.400
    3     X5-1        true   0.315
    4     X5-Link     false  0.300


trajGen = 

 &lt;a href="matlab:helpPopup HebiTrajectoryGenerator"&gt;HebiTrajectoryGenerator&lt;/a&gt; with properties:

      algorithm: UnconstrainedQp
    minDuration: 0.5 [s]
    speedFactor: 0.5



group = 

 &lt;a href="matlab:helpPopup HebiGroup"&gt;HebiGroup&lt;/a&gt; with properties:

    feedbackFrequency: 100 [Hz]
      commandLifetime: 0.25 [s]
           numModules: 2
              logPath: []

    Module  Family           Name             Serial Number  
    ------  ---------------  ---------------  ---------------
    1       2dof             base             X-00134        
    2       2dof             knee             X-00148        

</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
% This example shows howto use the HebiTrajectoryGenerator API to create
% paths to smoothly move through waypoints.
% 
% Requirements:  MATLAB 2013b or higher
%
% Author:        Florian Enner
% Created:       14 July, 2017
% API:           hebi-matlab-1.0
%
% Copyright 2017 HEBI Robotics

%% General
% For series elastic actuators such as the X-series modules it is important
% to command smooth trajectories to avoid oscillations induced by the 
% spring element. Additionally, it helps significantly to not only command
% positions, but also velocities and if possible torques.
%
% Trajectories work on a joint level and are technically independent of 
% the kinematic configuration. The API however requires knowledge of 
% HebiKinematics to access meta-data such as velocity limits. Thus, 
% position and velocity control can be done with only knowledge of the
% number of joints in a system. A full model of the system is however 
% required for
%
% * Torque control, i.e., converting joint accelerations to corresponding 
%   torques and forces
% * 'Linear'-type trajectories that move the end-effector in world
%   coordinates

%% Single Actuator Joint Trajectory
% The following exampe creates a trajectory through position waypoints  
% for a single actuator. The time vector can be automatically determined
% based on the joint limits. Alternatively the time can be set manually.
%
% * 'Duration' sets the total desired duration
% * 'Time' sets the times at which each waypoint should be hit
%
% For more options please see our online documentation or the corresponding
% help files.

% Setup single module for accessing meta-data
kin = HebiKinematics();
kin.addBody('X5-1');
trajGen = HebiTrajectoryGenerator(kin);
trajGen.setSpeedFactor(0.5); % slow down to half speed (good for testing)

% Calculate trajectory through position waypoints
waypoints = [0 2 -1 -2 1 0];
trajectory = trajGen.newJointMove(waypoints);

%%%

% Evaluate trajectory at 100 Hz resolution
t = 0:0.01:trajectory.getDuration();
[p,v,a] = trajectory.getState(t); % scalar or vector
display(waypoints);

% Display result
plot(t,p); hold on; grid on;
plot(t,v);
plot(t,a);
tWpt = trajectory.getWaypointTime();
plot(tWpt, trajectory.getState(tWpt), 'bo'); hold off;
legend position velocity acceleration waypoint
xlabel('time [s]');
ylabel('value [rad, rad/s, rad/s^2]');

%% Moving a robot to random waypoints
% In addition to providing low-level access to the raw trajectory, we
% provide convenience wrappers that simplify interactions with the 
% HebiGroup and HebiKinematics APIs.
%
% 'moveJoint()' moves between waypoints and blocks until the trajectory is
% executed.
%
% <<resources/2dof_RR_ik_xy.png>>
%

% Setup 2 dof planar RR arm
kin = HebiKinematics();
kin.addBody('X5-4'); % base joint
kin.addBody('X5-Link', 'ext', 0.35, 'twist', pi);
kin.addBody('X5-1');
kin.addBody('X5-Link', 'ext', 0.25, 'twist', pi);

% Setup trajectory generator
trajGen = HebiTrajectoryGenerator(kin);
trajGen.setSpeedFactor(0.5);
trajGen.setMinDuration(0.5);

% Connect to modules (replace names with your own)
group = HebiLookup.newGroupFromNames('2dof', {'base', 'knee'});

% Determine direction of gravity to compensate for gravitational effects
fbk = group.getNextFeedback(); % assume fixed base
gravityVec = -[fbk.accelX(1) fbk.accelY(1) fbk.accelZ(1)];

% Move to random waypoints
current = fbk.position;
for i = 1:20
    
    next = (rand(size(current)) - 0.5) * pi/2; % max +/- pi/2 
    trajGen.moveJoint(group,      ... % target actuators
        [current; next],          ... % waypoints
        'GravityVec', gravityVec, ... % compensate for gravity
        'EnableDynamicsComp', true);  % compensate for accelerations
    current = next;
    
end

%%%

% Display
display(kin);
display(trajGen);
display(group);




##### SOURCE END #####
--></body></html>